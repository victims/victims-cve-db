#!/usr/bin/env python

from logging import basicConfig, getLogger, INFO
from os import getcwd, walk
from os.path import exists, isfile, join, dirname, basename
from re import compile as regex_compile, findall, search, IGNORECASE
from sys import argv, exit, version

from yaml import safe_load as load

basicConfig(format='[%(levelname)s] %(message)s', level=INFO)
log = getLogger('validate-yaml')

# python3 compatibility
if version[0] >= '3':
    long = int

# Default language is python
_LANGUAGE = 'python'


class YAMLValidationError(Exception):
    pass


class FieldValidator():

    def __init__(self, validators=[], required=True):
        self._validators = validators
        self._required = required

    def is_required(self):
        return self._required

    def validate(self, value):
        for validator in self._validators:
            if not validator(value):
                raise YAMLValidationError('Validation Failed')


def is_string(arg, allow_multiline=False):
    if not isinstance(arg, str):
        log.error('String value expected, got %s', str(type(arg)))
        return False

    if not allow_multiline:
        if arg.find('\n') >= 0 or arg.find('\r') >= 0:
            log.error('Single line string value expected, got multiline.')
            return False

    return True


def is_file_hashes(arg, allow_multiline=False):
    if not isinstance(arg, list):
        log.error('List value expected, got %s', str(type(arg)))
        return False

    malformed = False
    for item in arg:
        if not item.get('name') or not item.get('hash'):
            log.error('Expected a name and hash.')
            malformed = True

    return not malformed


def is_text(arg):
    return is_string(arg, True)


def is_number(arg):
    if not isinstance(arg, (int, long, float, complex)):
        log.error('A number was expected, got %s', str(type(arg)))
        return False

    return True


def is_cve(arg):
    if is_string(arg):
        if search('^[0-9]{4}-[0-9]{4,}$', arg) is not None:
            return True

    log.error('Invalid CVE id: %s', arg)
    return False


def is_cvss(arg):
    if is_number(arg):
        if arg >= 0 and arg <= 10:
            return True
    log.error('Invalid CVSS score. Must be a number in the range 0-10')
    return False


def is_list(arg):
    if not isinstance(arg, list):
        log.error('List value was expected, got %s', str(type(arg)))
        return False

    return True


# http://stackoverflow.com/a/7160778/1874604
URL_REGEX = regex_compile(
    r'^(?:http|ftp)s?://'
    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'
    r'localhost|'
    r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'
    r'(?::\d+)?'
    r'(?:/?|[/?]\S+)$', IGNORECASE)


def is_url(arg):
    if not URL_REGEX.match(arg):
        log.error('URL expected, got "%s"', arg)
        return False

    return True


def is_references(arg):
    if not is_list(arg):
        return False

    for item in arg:
        if not is_string(item) or not is_url(item):
            return False

    return True


VERSION_REGEX = regex_compile(
    r'^(?P<condition>[><=]=)'
    r'(?P<version>[^, ]+)'
    r'(?:,(?P<series>[^, ]+)){0,1}$'
)


def is_version(arg):
    if not is_list(arg):
        return False

    for item in arg:
        if not is_string(item):
            return False

        match = VERSION_REGEX.search(item)
        if match is None:
            log.error('Invalid version "%s"', item)
            return False

        version = match.group('version')
        series = match.group('series')
        if series and not version.startswith(series):
            log.error(
                'Invalid series "%s" given in version string "%s"',
                series, item
            )
            return False

    return True


def get_required(fields):
    return [field for field in fields if fields[field].is_required()]


LANGUAGE_FIELDS = {
    'python': {
        'name': FieldValidator([is_string]),
        'version': FieldValidator([is_version]),
        'fixedin': FieldValidator([is_version], False),
        'unaffected': FieldValidator([is_version], False),
    },
    'java': {
        'groupId': FieldValidator([is_string]),
        'artifactId': FieldValidator([is_string]),
        'version': FieldValidator([is_version]),
        'fixedin': FieldValidator([is_version], False),
        'unaffected': FieldValidator([is_version], False),
    }
}


def is_valid_doc(doc, fields, parents=[]):
    valid = True

    # Validate required fields
    for key in get_required(fields):
        if key not in doc.keys():
            log.error('Field "%s" is required but not provided.', key)
            valid = False

    # Validating fields names and values
    for key in doc.keys():
        try:
            if key not in fields.keys():
                log.error('Field "%s" is unknown.', key)
                raise YAMLValidationError()
            log.info('Validating field %s', '.'.join(parents + [key]))
            fields[key].validate(doc[key])
        except YAMLValidationError:
            valid = False
            continue

    return valid


def is_coherent_with_filename(doc, filename):
    """
    Validates that the CVE id is matching the filename.
    """
    if 'cve' in doc:
        doc_year, doc_id = doc['cve'].split('-')

        try:
            file_id = findall('(\d+).yaml$', basename(filename))[-1]
            if file_id != doc_id:
                log.error(
                    'Document specified "%s" expected "%s" (filename). '
                    'Invalid CVE id.', doc['cve'], filename_cve)
                return False
        except IndexError:
            log.error('Unexpected filename "%s"', filename)
            return False

        try:
            file_year = findall('(\d+)$', dirname(filename))[-1]
            if file_year != doc_year:
                log.error(
                    'Document specified "%s" expected "%s" (filename). '
                    'Invalid CVE year.', doc['cve'], filename_cve)
                return False
        except IndexError:
            log.warn(
                'Could not verify year using filepath provided "%s", skipping verification',
                filename
            )

    return True


def is_affected(arg):
    if not is_list(arg):
        return False

    language_fields = LANGUAGE_FIELDS.get(_LANGUAGE, {})
    for item in arg:
        if not is_valid_doc(item, language_fields, ['affected']):
            return False

    return True


COMMON_FIELDS = {
    'cve': FieldValidator([is_string, is_cve]),
    'title': FieldValidator([is_string]),
    'description': FieldValidator([is_text], False),
    'cvss_v2': FieldValidator([is_cvss], False),
    'cvss_v3': FieldValidator([is_cvss], False),
    'references': FieldValidator([is_references], False),
    'affected': FieldValidator([is_affected]),
    'hash': FieldValidator([is_string], False),
    'file_hashes': FieldValidator([is_file_hashes], False),
    'package_urls': FieldValidator([is_references]),
}


def validate(filename):
    if not isfile(filename):
        log.error('%s is not a valid file. Skipping.', filename)
        return 1

    with open(filename, 'r') as f:
        log.info('Validating %s', filename)
        doc = load(f.read())
        if not is_valid_doc(doc, COMMON_FIELDS) \
                or not is_coherent_with_filename(doc, filename):
            log.error('Document %s is invalid.', filename)
            return 1

    log.info('Document %s is valid.', filename)
    return 0


def usage():
    print('Usage: %s <language> file1 ... fileN\n')
    print('Available Languages: %s' % (', '.join(LANGUAGE_FIELDS.keys())))
    exit(1)


def get_all_records(lang):
    """
    Fetch filepaths of all records for a given language
    """
    target_dir = join(getcwd(), 'database', lang)

    if not exists(target_dir):
        log.error('Database directory not found: %s', target_dir)
        exit(1)

    records = []
    for root, _, files in walk(target_dir):
        records += [
            join(root, name)
            for name in files
            if name.endswith('.yaml')
        ]

    return records


if __name__ == '__main__':

    if len(argv) == 1:
        log.error('No arguments were provided. Exiting.')
        usage()

    _LANGUAGE = argv[1]
    if _LANGUAGE not in LANGUAGE_FIELDS.keys():
        log.error('Invalid language given.')
        usage()

    invalid_count = 0

    # if files given as arguments use it; else validate all records for language
    records = argv[2:] if len(argv) > 2 else get_all_records(_LANGUAGE)
    for arg in records:
        invalid_count += validate(arg)

    print('%s error%s found during validation.' % (
        invalid_count, 's' if invalid_count else ''))
    exit(invalid_count)
