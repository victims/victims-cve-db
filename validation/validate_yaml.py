#!/usr/env python

from logging import basicConfig, getLogger, INFO
import os
from os.path import isfile
from re import compile as regex_compile, search, IGNORECASE
from sys import argv, exit

from yaml import safe_load as load

basicConfig(format='[%(levelname)s] %(message)s', level=INFO)
log = getLogger('validate-yaml')


# Default language is python
_LANGUAGE = 'python'


class YAMLValidationError(Exception):
    pass


class FieldValidator():
    def __init__(self, validators=[], required=True):
        self._validators = validators
        self._required = required

    def is_required(self):
        return self._required

    def validate(self, value):
        for validator in self._validators:
            if not validator(value):
                raise YAMLValidationError('Validation Failed')


def is_string(arg, allow_multiline=False):
    if not isinstance(arg, str):
        log.error('String value expected, got %s', str(type(arg)))
        return False

    if not allow_multiline:
        if arg.find('\n') >= 0 or arg.find('\r') >= 0:
            log.error('Single line string value expected, got multiline.')
            return False

    return True


def is_text(arg):
    return is_string(arg, True)


def is_number(arg):
    if not isinstance(arg, (int, long, float, complex)):
        log.error('A number was expected, got %s', str(type(arg)))
        return False

    return True


def is_cve(arg):
    if is_string(arg):
        if search('^[0-9]{4}-[0-9]{4,}$', arg) is not None:
            return True

    log.error('Invalid CVE id: %s', arg)
    return False


def is_cvss_v2(arg):
    if is_number(arg):
        if arg >= 0 and arg <= 10:
            return True
    log.error('Invalid CVSS v2 score.')
    return False


def is_list(arg):
    if not isinstance(arg, list):
        log.error('List value was expected, got %s', str(type(arg)))
        return False

    return True


# http://stackoverflow.com/a/7160778/1874604
URL_REGEX = regex_compile(
    r'^(?:http|ftp)s?://'
    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'
    r'localhost|'
    r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'
    r'(?::\d+)?'
    r'(?:/?|[/?]\S+)$', IGNORECASE)


def is_url(arg):
    if not URL_REGEX.match(arg):
        log.error('URL expected, got "%s"', arg)
        return False

    return True


def is_references(arg):
    if not is_list(arg):
        return False

    for item in arg:
        if not is_string(item) or not is_url(item):
            return False

    return True


VERSION_REGEX = regex_compile(
    r'^(?P<condition>[><=]=)'
    r'(?P<version>[^, ]+)'
    r'(?:,(?P<series>[^, ]+)){0,1}$'
)


def is_version(arg):
    if not is_list(arg):
        return False

    for item in arg:
        if not is_string(item):
            return False

        match = VERSION_REGEX.search(item)
        if match is None:
            log.error('Invalid version "%s"', item)
            return False

        version = match.group('version')
        series = match.group('series')
        if series and not version.startswith(series):
            log.error(
                'Invalid series "%s" given in version string "%s"',
                series, item
            )
            return False

    return True


def get_required(fields):
    return [field for field in fields if fields[field].is_required()]


LANGUAGE_FIELDS = {
    'python': {
        'name': FieldValidator([is_string]),
        'version': FieldValidator([is_version]),
        'fixedin': FieldValidator([is_version], False),
        'unaffected': FieldValidator([is_version], False),
    },
    'java': {
        'groupId': FieldValidator([is_string]),
        'artifactId': FieldValidator([is_string]),
        'version': FieldValidator([is_version]),
        'fixedin': FieldValidator([is_version], False),
        'unaffected': FieldValidator([is_version], False),
    }
}

#Use to extract the year and the id from the path (ie: '.../2015/1337.yaml')
REGEX_FILENAME_PARTS = regex_compile('[/\\\\](\d+)[/\\\\](\d+).yaml')

def is_valid_doc(doc, fields, parents=[]):
    valid = True

    #Validate required fields
    for key in get_required(fields):
        if key not in doc.keys():
            log.error('Field "%s" is required but not provided.', key)

    #Validating fields names and values
    for key in doc.keys():
        try:
            if key not in fields.keys():
                log.error('Field "%s" is unknown.', key)
                raise YAMLValidationError()
            log.info('Validating field %s', '.'.join(parents + [key]))
            fields[key].validate(doc[key])
        except YAMLValidationError:
            valid = False
            continue

    return valid


def is_coherent_with_filename(doc, filename):
    """
    Validates that the CVE id is matching the filename.
    """
    if ('cve' in doc):
        doc_year,doc_id = doc['cve'].split('-')

        results = REGEX_FILENAME_PARTS.findall(filename)
        if(len(results)==1):
            file_year, file_id = results[0]
            filename_cve = "-".join(results[0])
            if(doc_year != file_year):
                log.error('Document specified "%s" expected "%s" (filename). Invalid CVE year.', doc['cve'], filename_cve)
                return False
            if(doc_id != file_id):
                log.error('Document specified "%s" expected "%s" (filename). Invalid CVE id.', doc['cve'], filename_cve)
                return False
        else:
            log.error('Unexpected filename "%s"', filename)
            return False
    return True

def is_affected(arg):
    if not is_list(arg):
        return False

    language_fields = LANGUAGE_FIELDS.get(_LANGUAGE, {})
    for item in arg:
        if not is_valid_doc(item, language_fields, ['affected']):
            return False

    return True


COMMON_FIELDS = {
    'cve': FieldValidator([is_string, is_cve]),
    'title': FieldValidator([is_string]),
    'description': FieldValidator([is_text], False),
    'cvss_v2': FieldValidator([is_cvss_v2], False),
    'references': FieldValidator([is_references], False),
    'affected': FieldValidator([is_affected])
}


def validate(filename):
    if not isfile(filename):
        log.error('%s is not a valid file. Skipping.', filename)
        return 1

    with open(filename, 'r') as f:
        log.info('Validating %s', filename)
        doc = load(f.read())
        if not is_valid_doc(doc, COMMON_FIELDS) or not is_coherent_with_filename(doc,filename):
            log.error('Document %s is invalid.', filename)
            return 1

    log.info('Document %s is valid.', filename)
    return 0


def usage():
    print('Usage: %s <language> file1 ... fileN\n')
    print('Available Languages: %s' % (', '.join(LANGUAGE_FIELDS.keys())))
    exit(1)


if __name__ == '__main__':

    if len(argv) == 1:
        log.error('No arguments were provided. Exiting.')
        usage()

    _LANGUAGE = argv[1]
    if _LANGUAGE not in LANGUAGE_FIELDS.keys():
        log.error('Invalid language given.')
        usage()

    invalid_count = 0
    if(len(argv)> 2):
        #Validate a single file
        for arg in argv[2:]:
            invalid_count += validate(arg)
    else:
        #Validate all the files for the given language
        target_dir = 'database/'+_LANGUAGE
        for root, dirs, files in os.walk(target_dir):
            for name in files:
                if name.endswith('.yaml'):
                    invalid_count += validate(os.path.join(root, name))

    print('%s error%s found during validation.' % (invalid_count,"s" if invalid_count else ""))
    exit(invalid_count)
